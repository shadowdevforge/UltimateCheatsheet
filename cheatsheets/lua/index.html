<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lua Cheatsheet - SyntaxForge</title>
    <meta name="description" content="A comprehensive cheatsheet for the Lua programming language, covering tables, metatables, coroutines, and more.">
    
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ™</text></svg>">
    
    <link id="hljs-light-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@catppuccin/highlightjs@0.1.4/css/catppuccin-latte.css" disabled>
    <link id="hljs-dark-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@catppuccin/highlightjs@0.1.4/css/catppuccin-macchiato.css" disabled>

    <script>
        // Immediately-invoked function to set theme before page render.
        (function() {
            function applyTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                document.getElementById('hljs-light-theme').disabled = theme === 'dark';
                document.getElementById('hljs-dark-theme').disabled = theme === 'light';
            }
            const preferredTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            applyTheme(preferredTheme);
        })();
    </script>

    <!-- Page-specific styling for the Lua theme color -->
    <style>
      body {
        --glow-color: #c6a0f6; /* Lua Mauve */
      }
    </style>
</head>
<body>
    <canvas id="cmatrix"></canvas>

    <header class="header">
        <a href="/SyntaxForge/" class="home-link">SyntaxForge</a>
        <div class="theme-switcher-container">
            <label for="theme-toggle" class="theme-toggle-label">
                <input type="checkbox" id="theme-toggle" class="theme-toggle-input">
                <span class="theme-toggle-slider"></span>
            </label>
        </div>
        <div class="hero">
            <h1 class="hero-title">Lua</h1>
            <p class="hero-tagline">A powerful, efficient, lightweight, embeddable scripting language.</p>
        </div>
    </header>

    <main class="container">
        <div class="view-switcher">
            <button id="show-cheatsheet" class="view-btn active">Cheatsheet</button>
            <button id="show-projects" class="view-btn">Projects</button>
        </div>

        <div id="cheatsheet-content">
            <nav class="toc-container card">
                <h2>Table of Contents</h2>
                <ul id="toc-list"></ul>
            </nav>

            <section id="variables-types" class="card">
                <h2 class="card-title">1. Variables & Data Types</h2>
                <p>Variables are dynamically typed and global by default. Use the `local` keyword to limit scope.</p>
                <pre><code class="language-lua">
-- By default, variables are global
global_var = "I am global"

-- Use 'local' for block scope (best practice)
local name = "SyntaxForge" -- string
local version = 5.4         -- number (float)
local is_fast = true        -- boolean
local no_value = nil        -- nil (represents absence of value)

-- All types in Lua:
-- nil, boolean, number, string, function, userdata, thread, and table.

print(name, version, is_fast, no_value)
                </code></pre>
            </section>
            
            <section id="tables" class="card">
                <h2 class="card-title">2. Tables: The All-in-One Data Structure</h2>
                <p>Tables are the only data structuring mechanism in Lua. They can be used as arrays, dictionaries, or objects.</p>
                <pre><code class="language-lua">
-- Table used as an array (list)
local fruits = {"apple", "banana", "cherry"}
print(fruits[1]) -- NOTE: Lua indices start at 1

-- Table used as a dictionary (hash map)
local person = {
    name = "Alice",
    age = 30
}
person.city = "New York" -- Add a new key-value pair
print(person.name, person["age"])

-- Mixed table
local mixed = {10, 20, x = "hello", y = "world"}
print(mixed[1], mixed.x)
                </code></pre>
            </section>

            <section id="control-flow" class="card">
                <h2 class="card-title">3. Control Flow</h2>
                <p>Lua has `if/then/elseif/else`, `while`, `repeat until`, and `for` loops.</p>
                <pre><code class="language-lua">
local temp = 25
if temp > 30 then
    print("It's hot")
elseif temp > 20 then
    print("It's warm")
else
    print("It's cool")
end

-- While loop
local i = 1
while i <= 3 do
    print("while:", i)
    i = i + 1
end

-- Repeat until loop (always executes at least once)
local j = 1
repeat
    print("repeat:", j)
    j = j + 1
until j > 3

-- Numeric for loop (start, end, step)
for i = 1, 5, 2 do
    print("for:", i) -- Prints 1, 3, 5
end

-- Generic for loop with pairs (for dictionaries)
local person = {name = "Bob", age = 42}
for key, value in pairs(person) do
    print(key, value)
end
                </code></pre>
            </section>
            
            <section id="functions" class="card">
                <h2 class="card-title">4. Functions</h2>
                <p>Functions are first-class citizens. They can be stored in variables, passed as arguments, and returned from other functions.</p>
                <pre><code class="language-lua">
-- Simple function
function add(a, b)
    return a + b
end

-- Functions can be assigned to variables
local my_add = add
print(my_add(10, 5))

-- Functions can return multiple values
function get_point()
    return 10, 20
end
local x, y = get_point()
print(x, y)

-- Variadic function (accepts variable number of arguments)
function sum(...)
    local total = 0
    for _, num in ipairs({...}) do
        total = total + num
    end
    return total
end
print(sum(1, 2, 3, 4, 5))
                </code></pre>
            </section>

            <section id="metatables" class="card">
                <h2 class="card-title">5. Metatables & Metamethods</h2>
                <p>Metatables allow you to change the behavior of tables (and other types). Metamethods define how operators work.</p>
                <pre><code class="language-lua">
local vector1 = {x = 10, y = 20}
local vector2 = {x = 5, y = 7}

local metatable = {
    -- The '__add' metamethod is called when '+' is used on tables with this metatable
    __add = function(v1, v2)
        return {x = v1.x + v2.x, y = v1.y + v2.y}
    end
}

-- Apply the metatable to our vectors
setmetatable(vector1, metatable)
setmetatable(vector2, metatable)

local result_vector = vector1 + vector2 -- This now works!
print(result_vector.x, result_vector.y) -- Prints 15 27
                </code></pre>
            </section>
            
            <section id="modules" class="card">
                <h2 class="card-title">6. Modules</h2>
                <p>Modules allow you to organize your code into separate files. They are tables returned by the `require` function.</p>
                <pre><code class="language-lua">
-- In a file named 'mylib.lua'
local M = {} -- Create a table for the module

function M.say_hello(name)
    return "Hello, " .. name
end

return M -- Return the module table

-- In your main script ('main.lua')
local mylib = require("mylib") -- Load the module

print(mylib.say_hello("Forge"))
                </code></pre>
            </section>

            <section id="coroutines" class="card">
                <h2 class="card-title">7. Coroutines</h2>
                <p>Coroutines provide collaborative multitasking. They allow a function to suspend its execution (`yield`) and be resumed later.</p>
                <pre><code class="language-lua">
local co = coroutine.create(function()
    print("Coroutine started")
    coroutine.yield(1) -- Suspend execution, return 1
    print("Coroutine resumed")
    coroutine.yield(2) -- Suspend again, return 2
end)

print(coroutine.status(co)) -- "suspended"

local status, value1 = coroutine.resume(co)
print(status, value1) -- true, 1

print(coroutine.status(co)) -- "suspended"

local status, value2 = coroutine.resume(co)
print(status, value2) -- true, 2

print(coroutine.status(co)) -- "dead"
                </code></pre>
            </section>
        </div>

        <div id="projects-content" class="hidden">
            <div class="project-card card">
                <h2 class="card-title">1. Simple Config File Parser</h2>
                <p>A script that reads a simple `key = value` configuration file into a Lua table.</p>
                <pre><code class="language-lua">
-- config.txt file content:
-- name = SyntaxForge
-- version = 1.0
-- fullscreen = true

function load_config(filename)
    local config = {}
    for line in io.lines(filename) do
        -- string.match finds captures in a string
        local key, value = string.match(line, "([%w_]+)%s*=%s*(.*)")
        if key then
            config[key] = value
        end
    end
    return config
end

-- Assuming 'config.txt' exists in the same directory
local cfg = load_config("config.txt")
print("Name:", cfg.name)
print("Version:", cfg.version)
                </code></pre>
                <div class="explanation">
                    <h4>Code Explanation</h4>
                    <ul>
                        <li><strong><code>io.lines(filename)</code></strong>: Returns an iterator that reads one line from the file at a time.</li>
                        <li><strong><code>string.match</code></strong>: A powerful function for pattern matching. `([%w_]+)` captures one or more alphanumeric/underscore characters (the key), and `(.*)` captures the rest of the line (the value).</li>
                        <li>The script builds a table by dynamically adding keys and values parsed from the file.</li>
                    </ul>
                </div>
            </div>

            <div class="project-card card">
                <h2 class="card-title">2. Basic State Machine</h2>
                <p>A simple state machine, common in game development, where an entity's behavior is controlled by its current state.</p>
                <pre><code class="language-lua">
local Player = { state = "idle" }

local states = {
    idle = function(p)
        print("Player is idling.")
        p.state = "walking" -- Transition to the next state
    end,
    walking = function(p)
        print("Player is walking.")
        p.state = "attacking"
    end,
    attacking = function(p)
        print("Player is attacking!")
        p.state = "idle"
    end
}

function Player:update()
    -- Call the function corresponding to the current state
    states[self.state](self)
end

-- Simulate a few updates
Player:update()
Player:update()
Player:update()
                </code></pre>
                <div class="explanation">
                    <h4>Code Explanation</h4>
                    <ul>
                        <li><strong>Functions as Values</strong>: We store the behavior for each state as a function inside the `states` table.</li>
                        <li><strong>Dynamic Dispatch</strong>: `states[self.state]` retrieves the correct function from the table based on the player's current state string.</li>
                        <li>This pattern allows for clean separation of logic and makes it easy to add or modify states.</li>
                    </ul>
                </div>
            </div>

            <div class="project-card card">
                <h2 class="card-title">3. Fibonacci Generator with Coroutines</h2>
                <p>A classic example showing how coroutines can be used to create generators that yield values one at a time.</p>
                <pre><code class="language-lua">
function fibonacci_generator()
    local a, b = 0, 1
    return coroutine.create(function()
        while true do
            coroutine.yield(a)
            a, b = b, a + b
        end
    end)
end

local fib_gen = fibonacci_generator()

-- Get the first 5 Fibonacci numbers
for i = 1, 5 do
    local status, value = coroutine.resume(fib_gen)
    print(value)
end
                </code></pre>
                <div class="explanation">
                    <h4>Code Explanation</h4>
                    <ul>
                        <li>The coroutine runs an infinite loop, but it doesn't block the program.</li>
                        <li><strong><code>coroutine.yield(a)</code></strong>: This line is the key. It suspends the coroutine's execution and passes the current value of `a` back to the caller.</li>
                        <li><strong><code>coroutine.resume(fib_gen)</code></strong>: Each time this is called, the coroutine runs until it hits the next `yield`, then suspends again, preserving its local variables (`a` and `b`).</li>
                    </ul>
                </div>
            </div>

            <div class="project-card card">
                <h2 class="card-title">4. Vector "Class" with Metatables</h2>
                <p>Using tables and metatables to create a simple Vector object with operator overloading.</p>
                <pre><code class="language-lua">
Vector = {} -- Our "class" table
Vector.mt = { __index = Vector } -- The metatable

function Vector:new(x, y)
    local instance = {x = x or 0, y = y or 0}
    setmetatable(instance, self.mt)
    return instance
end

function Vector:magnitude()
    return math.sqrt(self.x^2 + self.y^2)
end

-- Metamethod for addition
Vector.mt.__add = function(v1, v2)
    return Vector:new(v1.x + v2.x, v1.y + v2.y)
end

-- Metamethod for string representation
Vector.mt.__tostring = function(v)
    return string.format("Vector(x=%.2f, y=%.2f)", v.x, v.y)
end

local v1 = Vector:new(3, 4)
local v2 = Vector:new(1, 2)
local v3 = v1 + v2

print(v1) -- Calls __tostring
print(v3) -- Calls __tostring
print("Magnitude of v1:", v1:magnitude())
                </code></pre>
                 <div class="explanation">
                    <h4>Code Explanation</h4>
                    <ul>
                        <li><strong><code>__index = Vector</code></strong>: This is the magic for inheritance/methods. If a key is not found in an `instance`, Lua looks for it in the `Vector` table.</li>
                        <li><strong><code>:new()</code></strong>: The colon is syntactic sugar. `Vector:new(...)` is equivalent to `Vector.new(Vector, ...)`, passing the table itself as the first argument (`self`).</li>
                        <li><strong><code>__add</code></strong> and <strong><code>__tostring</code></strong> are metamethods that overload the `+` operator and the `print()` function's behavior for our Vector objects.</li>
                    </ul>
                </div>
            </div>
            
            <div class="project-card card">
                <h2 class="card-title">5. Simple Plugin System</h2>
                <p>A host script that can load and run functionality from external Lua plugin files.</p>
                <pre><code class="language-lua">
-- In a file named 'plugin1.lua'
print("Plugin 1 loaded.")
function on_start()
    print("Plugin 1: Starting up!")
end

-- In the main host script ('host.lua')
local plugins = {}

function load_plugin(filename)
    -- dofile executes a file but doesn't cache it like require
    -- It runs in the current environment, so it can define global functions.
    local success, err = pcall(dofile, filename)
    if not success then
        print("Error loading plugin:", err)
        return
    end
    -- Assume the plugin defined a global on_start function
    if on_start then
        table.insert(plugins, on_start)
        on_start = nil -- Clear it for the next plugin
    end
end

-- Load plugins
load_plugin("plugin1.lua")
-- load_plugin("plugin2.lua") -- etc.

-- Run the startup function for all loaded plugins
print("\n--- Running plugins ---")
for _, startup_func in ipairs(plugins) do
    startup_func()
end
                </code></pre>
                <div class="explanation">
                    <h4>Code Explanation</h4>
                    <ul>
                        <li><strong><code>dofile(filename)</code></strong>: Executes the specified Lua file in the global environment of the caller. This is useful for simple plugins that need to define functions or modify the host's state.</li>
                        <li><strong><code>pcall(func, ...)</code></strong>: "Protected Call". It calls a function in protected mode, so if an error occurs within the function, it doesn't crash the host script. It returns the success status and any error message.</li>
                        <li>This pattern shows how a larger application can be made extensible by loading external Lua scripts at runtime.</li>
                    </ul>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <a href="/SyntaxForge/" class="footer-link">Back to Home</a>
        <a href="https://github.com/shadowedevforge/SyntaxForge" target="_blank" rel="noopener noreferrer" class="footer-link">Star the Repo</a>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/lua.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
