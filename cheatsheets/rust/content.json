{
    "meta": {
        "language": "Rust",
        "description": "A systems language pursuing the trifecta: safety, speed, and concurrency.",
        "color": "#f5a97f",
        "icon": "https://upload.wikimedia.org/wikipedia/commons/d/d5/Rust_programming_language_black_logo.svg"
    },
    "sections": [
        {
            "level": "I. Novice (The Basics)",
            "topics": [
                {
                    "title": "Variables & Mutability",
                    "desc": "Variables are immutable by default. Use `mut` to allow changes.",
                    "code": "let x = 5; \n// x = 6; // Compile Error!\n\nlet mut y = 10;\ny = 20; // Allowed\n\nconst MAX_POINTS: u32 = 100_000;"
                },
                {
                    "title": "Scalar Types",
                    "desc": "Rust is statically typed. Primitive types are allocated on the stack.",
                    "code": "let a: i32 = 42;        // Signed 32-bit integer\nlet b: f64 = 3.14;      // 64-bit Float\nlet c: bool = true;     // Boolean\nlet d: char = 'z';      // Unicode Character (4 bytes)\nlet t: (i32, f64) = (500, 6.4); // Tuple"
                },
                {
                    "title": "Control Flow",
                    "desc": "If expressions, loops, and while constructs. Note: `if` is an expression, it returns a value.",
                    "code": "let number = 3;\nlet result = if number < 5 { \"small\" } else { \"big\" };\n\n// Infinite loop\nloop {\n    println!(\"Again!\");\n    break;\n}\n\n// For loop (Ranges)\nfor i in 1..4 {\n    println!(\"{}\", i); // 1, 2, 3\n}"
                },
                {
                    "title": "Functions",
                    "desc": "Snake case naming. The last expression without a semicolon is the return value.",
                    "code": "fn main() {\n    let x = plus_one(5);\n}\n\nfn plus_one(x: i32) -> i32 {\n    x + 1 // Implicit return (no semicolon)\n}"
                }
            ]
        },
        {
            "level": "II. Apprentice (Ownership)",
            "topics": [
                {
                    "title": "Ownership Rules",
                    "desc": "1. Each value has an owner.\n2. Only one owner at a time.\n3. Value dropped when owner goes out of scope.",
                    "code": "let s1 = String::from(\"hello\");\nlet s2 = s1; \n// println!(\"{}\", s1); // Error! s1 moved to s2\n\nlet s3 = s2.clone(); // Deep copy\nprintln!(\"s2: {}, s3: {}\", s2, s3);"
                },
                {
                    "title": "Borrowing & References",
                    "desc": "Access data without taking ownership using `&`.",
                    "code": "fn calculate_len(s: &String) -> usize {\n    s.len()\n}\n\nlet s1 = String::from(\"hello\");\nlet len = calculate_len(&s1); // Pass reference (Borrow)\n\n// Mutable Reference (Only one allowed at a time)\nfn change(s: &mut String) {\n    s.push_str(\", world\");\n}"
                },
                {
                    "title": "The Slice Type",
                    "desc": "A reference to a contiguous sequence of elements in a collection.",
                    "code": "let s = String::from(\"hello world\");\nlet hello = &s[0..5]; // &str slice\nlet world = &s[6..11];\n\nlet a = [1, 2, 3, 4, 5];\nlet slice = &a[1..3]; // &[i32]"
                }
            ]
        },
        {
            "level": "III. Journeyman (Structure)",
            "topics": [
                {
                    "title": "Structs",
                    "desc": "Custom data types to group related values.",
                    "code": "struct User {\n    username: String,\n    active: bool,\n}\n\n// Tuple Struct\nstruct Color(i32, i32, i32);\n\nlet user1 = User {\n    username: String::from(\"shadow\"),\n    active: true,\n};"
                },
                {
                    "title": "Enums",
                    "desc": "Define a type by enumerating its possible variants. Can hold data.",
                    "code": "enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n\nlet msg = Message::Write(String::from(\"Hello\"));"
                },
                {
                    "title": "Pattern Matching",
                    "desc": "The `match` control flow construct. Must be exhaustive.",
                    "code": "match msg {\n    Message::Quit => println!(\"Quit\"),\n    Message::Move { x, y } => println!(\"Move {},{}\", x, y),\n    Message::Write(text) => println!(\"Text: {}\", text),\n}\n\n// if let syntax for single matches\nif let Some(3) = Some(3) {\n    println!(\"three\");\n}"
                },
                {
                    "title": "Error Handling",
                    "desc": "No exceptions. Use `Result<T, E>` and `Option<T>`.",
                    "code": "use std::fs::File;\n\nlet f = File::open(\"hello.txt\");\n\nlet f = match f {\n    Ok(file) => file,\n    Err(error) => panic!(\"Problem opening: {:?}\", error),\n};\n\n// The ? Operator (Propagate error)\nfn read_user() -> Result<String, std::io::Error> {\n    let mut s = String::new();\n    File::open(\"hello.txt\")?.read_to_string(&mut s)?;\n    Ok(s)\n}"
                }
            ]
        },
        {
            "level": "IV. Expert (Abstraction)",
            "topics": [
                {
                    "title": "Traits",
                    "desc": "Defining shared behavior (Interfaces).",
                    "code": "pub trait Summary {\n    fn summarize(&self) -> String;\n}\n\nimpl Summary for User {\n    fn summarize(&self) -> String {\n        format!(\"User: {}\", self.username)\n    }\n}\n\n// Trait Bounds\nfn notify<T: Summary>(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}"
                },
                {
                    "title": "Lifetimes",
                    "desc": "Ensuring references are valid as long as needed. Usually inferred.",
                    "code": "// 'a connects the lifetime of input to output\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}"
                },
                {
                    "title": "Closures & Iterators",
                    "desc": "Functional programming features.",
                    "code": "let v1 = vec![1, 2, 3];\n\n// Closure |param| body\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);"
                },
                {
                    "title": "Smart Pointers",
                    "desc": "Data structures that act like pointers but have extra capabilities.",
                    "code": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n// Box<T>: Heap allocation\nlet b = Box::new(5);\n\n// Rc<T>: Multiple owners (Reference Counting)\nlet a = Rc::new(5);\nlet b = Rc::clone(&a);\n\n// RefCell<T>: Interior Mutability\nlet c = RefCell::new(5);\n*c.borrow_mut() += 1;"
                }
            ]
        },
        {
            "level": "V. Grandmaster (Systems)",
            "topics": [
                {
                    "title": "Concurrency",
                    "desc": "Fearless concurrency with threads and message passing.",
                    "code": "use std::thread;\nuse std::sync::mpsc;\n\nlet (tx, rx) = mpsc::channel();\n\nthread::spawn(move || {\n    tx.send(\"ping\").unwrap();\n});\n\nprintln!(\"Received: {}\", rx.recv().unwrap());"
                },
                {
                    "title": "Shared State (Mutex)",
                    "desc": "Atomic reference counting with Mutex locks.",
                    "code": "use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet counter = Arc::new(Mutex::new(0));\nlet mut handles = vec![];\n\nfor _ in 0..10 {\n    let counter = Arc::clone(&counter);\n    let handle = thread::spawn(move || {\n        let mut num = counter.lock().unwrap();\n        *num += 1;\n    });\n    handles.push(handle);\n}"
                },
                {
                    "title": "Async / Await",
                    "desc": "Cooperative multitasking (Requires a runtime like Tokio).",
                    "code": "async fn say_hello() {\n    println!(\"world\");\n}\n\n#[tokio::main]\nasync fn main() {\n    let op = say_hello();\n    println!(\"hello\");\n    op.await;\n}"
                },
                {
                    "title": "Unsafe Rust",
                    "desc": "Stepping out of the compiler's guarantees. Here be dragons.",
                    "code": "let mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n\nunsafe {\n    // Dereferencing raw pointers\n    println!(\"r1 is: {}\", *r1);\n    println!(\"r2 is: {}\", *r2);\n}"
                }
            ]
        }
    ]
}
